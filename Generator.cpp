#include "Generator.h"

#include <iostream>
#include <fstream>
#include <algorithm>

using namespace PReflTool;

static const char *s_generatedDir = "generated";

Generator::Generator(std::string file) {
  m_targetFile = std::filesystem::path{file};
  if (!(std::filesystem::exists(m_targetFile) && m_targetFile.has_stem())) {
    throw std::exception("file does not exist");
  }

  m_resultDir = m_targetFile.parent_path() / s_generatedDir;
  std::filesystem::create_directory(m_resultDir);
}

std::filesystem::path Generator::GetGeneratedFilePath() {
  return m_resultDir / (m_targetFile.stem().string() + ".gen.inl");
}

bool Generator::CheckModifyTime() {
  auto genFile = GetGeneratedFilePath();
  if (!std::filesystem::exists(genFile))
    return false;

  auto genTime = std::filesystem::last_write_time(genFile);
  auto tarTime = std::filesystem::last_write_time(m_targetFile);

  std::chrono::duration<double, std::centi> elapsed = genTime - tarTime;
  return elapsed.count() > 0;
}

void Generator::Generate() {
  AddIncludePathToTarget();

  std::ofstream genFile;

  // open generated file
  genFile.open(GetGeneratedFilePath().string(),
               std::ios::out | std::ios::trunc);

  auto fileName = m_targetFile.stem().string();
  std::transform(fileName.begin(), fileName.end(), fileName.begin(),
                 [](unsigned char c) { return toupper(c); });
  genFile << "//===================================================\n";
  genFile << "// Automatically generated by Pupil Reflection Tool\n";
  genFile << "//===================================================\n\n";
  genFile << "#ifndef __" << fileName << "__GEN_INL__\n";
  genFile << "#define __" << fileName << "__GEN_INL__\n";
  genFile << "namespace PRefl {\n";

  for (auto &record : m_records) {
    std::string name = "";
    const auto &nsps = record->GetNamespaces();
    for (auto nsp : nsps) {
      name += nsp + "::";
    }
    name += record->GetName();

    std::string tmpDecl = "";
    tmpDecl = "template<";
    const auto &tmps = record->GetTemplates();
    if (tmps.size() > 0) {
      name += "<";
      for (size_t i = 0; i < tmps.size() - 1; ++i) {
        tmpDecl += "typename " + tmps[i] + ", ";
        name += tmps[i] + ", ";
      }
      tmpDecl += "typename " + tmps.back();
      name += tmps.back() + ">";

    }
    tmpDecl += ">";
    genFile << tmpDecl << "\n";
    genFile << "struct ReflData<" << name << ">\n";
    genFile << "{\n";

    genFile << "    constexpr static bool hasData = ";
    auto &fields = record->GetFields();
    genFile << (fields.size() > 0 ? "true" : "false") << ";\n";

    genFile << "    constexpr static bool hasBases = ";
    auto &bases = record->GetBases();
    genFile << (bases.size() > 0 ? "true" : "false") << ";\n";

    if (bases.size() > 0) {
      genFile << "    constexpr static auto bases = ReflDataArray {\n";
      for (size_t i = 0; i < bases.size() - 1; ++i) {
        genFile << "        ReflData<" << bases[i] << "> {},\n";
      }
      genFile << "        ReflData<" << bases.back() << "> {}\n";
      genFile << "    };\n";
    }

    if (fields.size() > 0) {
      genFile << "    constexpr static auto fields = FieldArray {\n";

      auto writeField = [&genFile, &name](const Field *field) {
        genFile << "        Field { Name<\"" << field->name << "\">{}, "
                << "&" << name << "::" << field->name << ",";
        if (field->attrs.size() > 2) {
          genFile << "\n            AttrArray{\n";
          for (size_t i = 0; i < field->attrs.size() - 1; ++i) {
            genFile << "                ";
            field->attrs[i]->Write(genFile);
            genFile << ",\n";
          }
          genFile << "                ";
          field->attrs.back()->Write(genFile);
          genFile << "\n            }\n        }";
        } else {
          genFile << " AttrArray {";
          if (field->attrs.size() > 0) {
            for (size_t i = 0; i < field->attrs.size() - 1; ++i) {
              field->attrs[i]->Write(genFile);
              genFile << ", ";
            }
            field->attrs.back()->Write(genFile);
          }
          genFile << "} }";
        }
      };
      for (size_t i = 0; i < fields.size() - 1; ++i) {
        writeField(fields[i].get());
        genFile << ",\n";
      }
      writeField(fields.back().get());
      genFile << "\n    };\n";
    }
    genFile << "};\n";
  }

  genFile << "}\n";
  genFile << "#endif\n";
  genFile.close();
}

void Generator::AddIncludePathToTarget() {
  std::string generatedFileName = GetGeneratedFilePath().filename().string();
  // Check whether the generated file has been included.
  {
    std::ifstream file(m_targetFile);
    std::string line;
    while (std::getline(file, line)) {
      auto incPos = line.find(generatedFileName);
      if (incPos != line.npos) {
        auto ignPos = line.find("//");
        if (incPos < ignPos) {
          file.close();
          return;
        }
      }
    }
    file.close();
  }

  // Add the 'include' code to the target file
  {
    std::ofstream file(m_targetFile, std::ios::out | std::ios::app);
    file << "\n// auto generated by PupilReflTool" << std::endl;
    file << "#include \"" << s_generatedDir << "/" << generatedFileName << "\""
         << std::endl;
    file.close();
  }
}